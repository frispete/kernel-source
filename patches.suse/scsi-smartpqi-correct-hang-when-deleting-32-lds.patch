From: Mahesh Rajashekhara <mahesh.rajashekhara@microsemi.com>
Date: Thu, 22 Aug 2019 15:39:31 -0500
Subject: scsi: smartpqi: correct hang when deleting 32 lds
Patch-mainline: v5.4-rc1
Git-commit: 530dd8a7a2b1ff2ee6c862ba250ca54ccc8c8c3e
References: bsc#1172418

When each ld is deleted, a rescan event is triggered in the driver. These
can stack up waiting on mutex_lock.

Change to mutex_try_lock and schedule a rescan for later.

Reviewed-by: Scott Benesh <scott.benesh@microsemi.com>
Reviewed-by: Kevin Barnett <kevin.barnett@microsemi.com>
Signed-off-by: Mahesh Rajashekhara <mahesh.rajashekhara@microsemi.com>
Signed-off-by: Don Brace <don.brace@microsemi.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Acked-by: Martin Wilck <mwilck@suse.com>
---
 drivers/scsi/smartpqi/smartpqi_init.c |   14 ++++++++------
 1 file changed, 8 insertions(+), 6 deletions(-)

--- a/drivers/scsi/smartpqi/smartpqi_init.c
+++ b/drivers/scsi/smartpqi/smartpqi_init.c
@@ -2235,18 +2235,20 @@ static void pqi_remove_all_scsi_devices(
 
 static int pqi_scan_scsi_devices(struct pqi_ctrl_info *ctrl_info)
 {
-	int rc;
+	int rc = 0;
 
 	if (pqi_ctrl_offline(ctrl_info))
 		return -ENXIO;
 
-	mutex_lock(&ctrl_info->scan_mutex);
-
-	rc = pqi_update_scsi_devices(ctrl_info);
-	if (rc)
+	if (!mutex_trylock(&ctrl_info->scan_mutex)) {
 		pqi_schedule_rescan_worker_delayed(ctrl_info);
 
-	mutex_unlock(&ctrl_info->scan_mutex);
+	} else {
+		rc = pqi_update_scsi_devices(ctrl_info);
+		if (rc)
+			pqi_schedule_rescan_worker_delayed(ctrl_info);
+		mutex_unlock(&ctrl_info->scan_mutex);
+	}
 
 	return rc;
 }
